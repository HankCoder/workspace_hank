// qwizard.sip generated by MetaSIP on Wed Oct  2 09:09:10 2013
//
// This file is part of the QtWidgets Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt5.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qwizard.h>
%End

class QWizard : QDialog
{
%TypeHeaderCode
#include <qwizard.h>
%End

public:
    enum WizardButton
    {
        BackButton,
        NextButton,
        CommitButton,
        FinishButton,
        CancelButton,
        HelpButton,
        CustomButton1,
        CustomButton2,
        CustomButton3,
        Stretch,
    };

    enum WizardPixmap
    {
        WatermarkPixmap,
        LogoPixmap,
        BannerPixmap,
        BackgroundPixmap,
    };

    enum WizardStyle
    {
        ClassicStyle,
        ModernStyle,
        MacStyle,
        AeroStyle,
    };

    enum WizardOption
    {
        IndependentPages,
        IgnoreSubTitles,
        ExtendedWatermarkPixmap,
        NoDefaultButton,
        NoBackButtonOnStartPage,
        NoBackButtonOnLastPage,
        DisabledBackButtonOnLastPage,
        HaveNextButtonOnLastPage,
        HaveFinishButtonOnEarlyPages,
        NoCancelButton,
        CancelButtonOnLeft,
        HaveHelpButton,
        HelpButtonOnRight,
        HaveCustomButton1,
        HaveCustomButton2,
        HaveCustomButton3,
    };

    typedef QFlags<QWizard::WizardOption> WizardOptions;
    QWizard(QWidget *parent /TransferThis/ = 0, Qt::WindowFlags flags = 0);
    virtual ~QWizard();
    int addPage(QWizardPage *page /Transfer/);
    void setPage(int id, QWizardPage *page /Transfer/);
    QWizardPage *page(int id) const;
    bool hasVisitedPage(int id) const;
    QList<int> visitedPages() const;
    void setStartId(int id);
    int startId() const;
    QWizardPage *currentPage() const;
    int currentId() const;
    virtual bool validateCurrentPage();
    virtual int nextId() const;
    void setField(const QString &name, const QVariant &value);
    QVariant field(const QString &name) const;
    void setWizardStyle(QWizard::WizardStyle style);
    QWizard::WizardStyle wizardStyle() const;
    void setOption(QWizard::WizardOption option, bool on = true);
    bool testOption(QWizard::WizardOption option) const;
    void setOptions(QFlags<QWizard::WizardOption> options);
    QFlags<QWizard::WizardOption> options() const;
    void setButtonText(QWizard::WizardButton which, const QString &text);
    QString buttonText(QWizard::WizardButton which) const;
    void setButtonLayout(const QList<QWizard::WizardButton> &layout);
    void setButton(QWizard::WizardButton which, QAbstractButton *button /Transfer/);
    QAbstractButton *button(QWizard::WizardButton which) const /Transfer/;
    void setTitleFormat(Qt::TextFormat format);
    Qt::TextFormat titleFormat() const;
    void setSubTitleFormat(Qt::TextFormat format);
    Qt::TextFormat subTitleFormat() const;
    void setPixmap(QWizard::WizardPixmap which, const QPixmap &pixmap);
    QPixmap pixmap(QWizard::WizardPixmap which) const;
    void setDefaultProperty(const char *className, const char *property, const char *changedSignal);
    virtual void setVisible(bool visible);
    virtual QSize sizeHint() const;

signals:
    void currentIdChanged(int id);
    void helpRequested();
    void customButtonClicked(int which);

public slots:
    void back();
    void next();
    void restart();

protected:
    virtual bool event(QEvent *event);
    virtual void resizeEvent(QResizeEvent *event);
    virtual void paintEvent(QPaintEvent *event);
    virtual void done(int result);
    virtual void initializePage(int id);
    virtual void cleanupPage(int id);

public:
    void removePage(int id);
    QList<int> pageIds() const;
    void setSideWidget(QWidget *widget /Transfer/);
    QWidget *sideWidget() const;

signals:
    void pageAdded(int id);
    void pageRemoved(int id);

private:
    QWizard(const QWizard &);
};

QFlags<QWizard::WizardOption> operator|(QWizard::WizardOption f1, QFlags<QWizard::WizardOption> f2);

class QWizardPage : QWidget
{
%TypeHeaderCode
#include <qwizard.h>
%End

public:
    explicit QWizardPage(QWidget *parent /TransferThis/ = 0);
    virtual ~QWizardPage();
    void setTitle(const QString &title);
    QString title() const;
    void setSubTitle(const QString &subTitle);
    QString subTitle() const;
    void setPixmap(QWizard::WizardPixmap which, const QPixmap &pixmap);
    QPixmap pixmap(QWizard::WizardPixmap which) const;
    void setFinalPage(bool finalPage);
    bool isFinalPage() const;
    void setCommitPage(bool commitPage);
    bool isCommitPage() const;
    void setButtonText(QWizard::WizardButton which, const QString &text);
    QString buttonText(QWizard::WizardButton which) const;
    virtual void initializePage();
    virtual void cleanupPage();
    virtual bool validatePage();
    virtual bool isComplete() const;
    virtual int nextId() const;

signals:
    void completeChanged();

protected:
    void setField(const QString &name, const QVariant &value);
    QVariant field(const QString &name) const;

public:
    void registerField(const QString &name, QWidget *widget, const char *property = 0, SIP_PYOBJECT changedSignal /DocType="signal"/ = 0);
%MethodCode
        QObject *receiver;
        QByteArray signal_signature;
        const char *signal;
        
        if (a3 && a3 != Py_None)
        {
            if ((sipError = pyqt5_get_pyqtsignal_parts(a3, &receiver, signal_signature)) == sipErrorNone)
            {
                if (receiver != a1)
                {
                    PyErr_SetString(PyExc_ValueError,
                            "the signal must be bound to the same QWidget instance");
                    sipError = sipErrorFail;
                }
                else
                {
                    signal = signal_signature.constData();
                }
            }
            else
            {
                // We don't set sipError to sipErrorContinue because we don't want to
                // go on to the next (ie. the real) registerField() overload.  That is
                // there only so that SIP generates the required public wrapper method
                // that we need to call below.  We don't want the user to call it.
                sipBadCallableArg(3, a3);
                sipError = sipErrorFail;
            }
        }
        else
        {
            signal = 0;
        }
        
        if (sipError == sipErrorNone)
        {
            Py_BEGIN_ALLOW_THREADS
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            sipCpp->registerField(*a0, a1, a2, signal);
        #else
            // We should really change SIP to implement /NoDerived/ for protected
            // methods rather than do this (possibly unsafe) cast.
            static_cast<sipQWizardPage *>(sipCpp)->sipProtect_registerField(*a0, a1, a2, signal);
        #endif
            Py_END_ALLOW_THREADS
        }
%End

protected:
    void registerField(const QString &name, QWidget *widget, const char *property = 0, const char *changedSignal = 0);
    QWizard *wizard() const;

private:
    QWizardPage(const QWizardPage &);
};

// Mapped type for QList<QWizard::WizardButton>.
%MappedType QList<QWizard::WizardButton> /DocType="list-of-QWizard.WizardButton"/
{
%TypeHeaderCode
#include <qwizard.h>
%End

%ConvertFromTypeCode
    // Create the list.
    PyObject *l;

    if ((l = PyList_New(sipCpp->size())) == NULL)
        return NULL;

    // Set the list elements.
    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QWizard::WizardButton e = sipCpp->at(i);
        PyObject *eobj;

        if ((eobj = sipConvertFromEnum(e, sipType_QWizard_WizardButton)) == NULL)
        {
            Py_DECREF(l);

            return NULL;
        }

        PyList_SET_ITEM(l, i, eobj);
    }

    return l;
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
    {
        if (!PyList_Check(sipPy))
            return 0;

        for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToEnum(PyList_GET_ITEM(sipPy, i), sipType_QWizard_WizardButton))
                return 0;

        return 1;
    }

    QList<QWizard::WizardButton> *ql = new QList<QWizard::WizardButton>;
 
    for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(sipPy); ++i)
    {
        long l = SIPLong_AsLong(PyList_GET_ITEM(sipPy, i));
        ql->append(static_cast<QWizard::WizardButton>(l));
    }
 
    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
%End
};
