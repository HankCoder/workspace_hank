// qaudioformat.sip generated by MetaSIP on Wed Oct  2 09:09:09 2013
//
// This file is part of the QtMultimedia Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt5.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


class QAudioFormat
{
%TypeHeaderCode
#include <qaudioformat.h>
%End

public:
    enum SampleType
    {
        Unknown,
        SignedInt,
        UnSignedInt,
        Float,
    };

    enum Endian
    {
        BigEndian,
        LittleEndian,
    };

    QAudioFormat();
    QAudioFormat(const QAudioFormat &other);
    ~QAudioFormat();
    bool operator==(const QAudioFormat &other) const;
    bool operator!=(const QAudioFormat &other) const;
    bool isValid() const;
    void setSampleSize(int sampleSize);
    int sampleSize() const;
    void setCodec(const QString &codec);
    QString codec() const;
    void setByteOrder(QAudioFormat::Endian byteOrder);
    QAudioFormat::Endian byteOrder() const;
    void setSampleType(QAudioFormat::SampleType sampleType);
    QAudioFormat::SampleType sampleType() const;
    void setSampleRate(int sampleRate);
    int sampleRate() const;
    void setChannelCount(int channelCount);
    int channelCount() const;
    qint32 bytesForDuration(qint64 duration) const;
    qint64 durationForBytes(qint32 byteCount) const;
    qint32 bytesForFrames(qint32 frameCount) const;
    qint32 framesForBytes(qint32 byteCount) const;
    qint32 framesForDuration(qint64 duration) const;
    qint64 durationForFrames(qint32 frameCount) const;
    int bytesPerFrame() const;
};

// Mapped type for QList<QAudioFormat::Endian>.
%MappedType QList<QAudioFormat::Endian> /DocType="list-of-QAudioFormat.Endian"/
{
%TypeHeaderCode
#include <qaudioformat.h>
%End

%ConvertFromTypeCode
    // Create the list.
    PyObject *l;

    if ((l = PyList_New(sipCpp->size())) == NULL)
        return NULL;

    // Set the list elements.
    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QAudioFormat::Endian e = sipCpp->at(i);
        PyObject *eobj;

        if ((eobj = sipConvertFromEnum(e, sipType_QAudioFormat_Endian)) == NULL)
        {
            Py_DECREF(l);

            return NULL;
        }

        PyList_SET_ITEM(l, i, eobj);
    }

    return l;
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
    {
        if (!PyList_Check(sipPy))
            return 0;

        for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToEnum(PyList_GET_ITEM(sipPy, i), sipType_QAudioFormat_Endian))
                return 0;

        return 1;
    }

    QList<QAudioFormat::Endian> *ql = new QList<QAudioFormat::Endian>;
 
    for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(sipPy); ++i)
    {
        long l = SIPLong_AsLong(PyList_GET_ITEM(sipPy, i));
        ql->append(static_cast<QAudioFormat::Endian>(l));
    }
 
    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
%End
};
// Mapped type for QList<QAudioFormat::SampleType>.
%MappedType QList<QAudioFormat::SampleType> /DocType="list-of-QAudioFormat.SampleType"/
{
%TypeHeaderCode
#include <qaudioformat.h>
%End

%ConvertFromTypeCode
    // Create the list.
    PyObject *l;

    if ((l = PyList_New(sipCpp->size())) == NULL)
        return NULL;

    // Set the list elements.
    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QAudioFormat::SampleType e = sipCpp->at(i);
        PyObject *eobj;

        if ((eobj = sipConvertFromEnum(e, sipType_QAudioFormat_SampleType)) == NULL)
        {
            Py_DECREF(l);

            return NULL;
        }

        PyList_SET_ITEM(l, i, eobj);
    }

    return l;
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
    {
        if (!PyList_Check(sipPy))
            return 0;

        for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(sipPy); ++i)
            if (!sipCanConvertToEnum(PyList_GET_ITEM(sipPy, i), sipType_QAudioFormat_SampleType))
                return 0;

        return 1;
    }

    QList<QAudioFormat::SampleType> *ql = new QList<QAudioFormat::SampleType>;
 
    for (SIP_SSIZE_T i = 0; i < PyList_GET_SIZE(sipPy); ++i)
    {
        long l = SIPLong_AsLong(PyList_GET_ITEM(sipPy, i));
        ql->append(static_cast<QAudioFormat::SampleType>(l));
    }
 
    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
%End
};
