// qsslcertificate.sip generated by MetaSIP on Wed Oct  2 09:09:08 2013
//
// This file is part of the QtNetwork Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt5.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (PyQt_SSL)

class QSslCertificate
{
%TypeHeaderCode
#include <qsslcertificate.h>
%End

public:
    enum SubjectInfo
    {
        Organization,
        CommonName,
        LocalityName,
        OrganizationalUnitName,
        CountryName,
        StateOrProvinceName,
        DistinguishedNameQualifier,
        SerialNumber,
        EmailAddress,
    };

    QSslCertificate(QIODevice *device, QSsl::EncodingFormat format = QSsl::Pem);
    QSslCertificate(const QByteArray &data = QByteArray(), QSsl::EncodingFormat format = QSsl::Pem);
    QSslCertificate(const QSslCertificate &other);
    ~QSslCertificate();
    bool operator==(const QSslCertificate &other) const;
    bool operator!=(const QSslCertificate &other) const;
    bool isNull() const;
    void clear();
    QByteArray version() const;
    QByteArray serialNumber() const;
    QByteArray digest(QCryptographicHash::Algorithm algorithm = QCryptographicHash::Md5) const;
    QStringList issuerInfo(QSslCertificate::SubjectInfo info) const;
    QStringList issuerInfo(const QByteArray &attribute) const;
    QStringList subjectInfo(QSslCertificate::SubjectInfo info) const;
    QStringList subjectInfo(const QByteArray &attribute) const;
    QMultiMap<QSsl::AlternativeNameEntryType, QString> subjectAlternativeNames() const;
    QDateTime effectiveDate() const;
    QDateTime expiryDate() const;
    QSslKey publicKey() const;
    QByteArray toPem() const;
    QByteArray toDer() const;
    static QList<QSslCertificate> fromPath(const QString &path, QSsl::EncodingFormat format = QSsl::Pem, QRegExp::PatternSyntax syntax = QRegExp::FixedString);
    static QList<QSslCertificate> fromDevice(QIODevice *device, QSsl::EncodingFormat format = QSsl::Pem);
    static QList<QSslCertificate> fromData(const QByteArray &data, QSsl::EncodingFormat format = QSsl::Pem);
    Qt::HANDLE handle() const;
    void swap(QSslCertificate &other);
    bool isBlacklisted() const;
    QList<QByteArray> subjectInfoAttributes() const;
    QList<QByteArray> issuerInfoAttributes() const;
    QList<QSslCertificateExtension> extensions() const;
    QString toText() const;
    static QList<QSslError> verify(QList<QSslCertificate> certificateChain, const QString &hostName = QString());
};

%End
%If (PyQt_SSL)
// Mapped type for QMultiMap<QSsl::AlternativeNameEntryType, QString>.
%MappedType QMultiMap<QSsl::AlternativeNameEntryType, QString> /DocType="dict-of-QSsl.AlternativeNameEntryType-list-of-str"/
{
%TypeHeaderCode
#include <QtCore/qmap.h>
#include <QtCore/qstring.h>
#include <QtNetwork/qssl.h>
%End

%ConvertFromTypeCode
    // Get the enum objects that are the dictionary keys.
    static PyObject *email_entry = NULL;
    static PyObject *dns_entry = NULL;

    if (email_entry == NULL)
    {
        email_entry = PyObject_GetAttrString((PyObject *)sipTypeAsPyTypeObject(sipType_QSsl),
                "EmailEntry");

        if (email_entry == NULL)
            return NULL;
    }

    if (dns_entry == NULL)
    {
        dns_entry = PyObject_GetAttrString((PyObject *)sipTypeAsPyTypeObject(sipType_QSsl),
                "DnsEntry");

        if (dns_entry == NULL)
            return NULL;
    }

    // Create the dictionary.
    PyObject *d = PyDict_New();

    if (d == NULL)
        return NULL;

    QList<QString> vl;

    // Handle the Qssl::EmailEntry key.
    vl = sipCpp->values(QSsl::EmailEntry);

    if (!vl.isEmpty())
    {
        PyObject *vlobj = PyList_New(vl.count());

        if (vlobj == NULL)
        {
            Py_DECREF(d);
            return NULL;
        }

        int rc = PyDict_SetItem(d, email_entry, vlobj);

        Py_DECREF(email_entry);
        Py_DECREF(vlobj);

        if (rc < 0)
        {
            Py_DECREF(d);
            return NULL;
        }

        for (int i = 0; i < vl.count(); ++i)
        {
            QString *s = new QString(vl.at(i));
            PyObject *vobj = sipConvertFromNewType(s, sipType_QString, sipTransferObj);

            if (vlobj == NULL)
            {
                Py_DECREF(d);
                return NULL;
            }

            PyList_SET_ITEM(vlobj, i, vobj);
        }
    }

    // Handle the Qssl::DnsEntry key.
    vl = sipCpp->values(QSsl::DnsEntry);

    if (!vl.isEmpty())
    {
        PyObject *vlobj = PyList_New(vl.count());

        if (vlobj == NULL)
        {
            Py_DECREF(d);
            return NULL;
        }

        int rc = PyDict_SetItem(d, dns_entry, vlobj);

        Py_DECREF(dns_entry);
        Py_DECREF(vlobj);

        if (rc < 0)
        {
            Py_DECREF(d);
            return NULL;
        }

        for (int i = 0; i < vl.count(); ++i)
        {
            QString *s = new QString(vl.at(i));
            PyObject *vobj = sipConvertFromNewType(s, sipType_QString, sipTransferObj);

            if (vlobj == NULL)
            {
                Py_DECREF(d);
                return NULL;
            }

            PyList_SET_ITEM(vlobj, i, vobj);
        }
    }

    return d;
%End

%ConvertToTypeCode
    if (sipIsErr == NULL)
    {
        // We don't support passing the type as an argument as it isn't
        // currently needed (and is unlikely to be in the future).
        PyErr_SetString(PyExc_NotImplementedError, "converting to QMultiMap<QSsl::AlternativeNameEntryType, QString> is unsupported");

        return 0;
    }

    // Keep the compiler quiet.
    sipPy = NULL;
    return 0;
%End
};
%End
